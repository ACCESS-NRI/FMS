<!-- using template.html -->
<!doctype html public "-//ietf//dtd html//en">
<html>

<head>
<meta name="description" content="">
<meta name="keywords" content="">
<link rel="stylesheet" href="http://www.gfdl.noaa.gov/~fms/style/balaji.css">

<title>diag_manager_mod: a parallel diagnostic interface for f90</title>
</head>

<body>

<!-- title using title stylespec -->
<div class="title">
<h1>diag_manager_mod</h1>
<h2> a parallel diagnostic interface for f90</h2>
<hr>
<tt>diag_manager_mod</tt> is a set of simple calls for parallel diagnostics on
distributed systems. <br>
It is geared toward the writing of data in netCDF
format. It requires the modules <br>
<ul>
<li> <a href="./diag_axis.html"><tt>diag_axis_mod</tt></a>
<li> <a href="./diag_output.html"><tt>diag_output_mod</tt></a>
<li> <a href="../time_manager/time_manager.html"><tt>time_manager_mod</tt></a>
<li> <a href="../utilities/utilities.html"><tt>utilities_mod</tt></a>.
<li> <a href="./mpp_domains.html"><tt>mpp_domains_mod</tt></a> and  
<li> <a href="./mpp_io.html"><tt>mpp_io_mod</tt></a>  
</ul>

<hr>

</div>

<p>
<br><a href="#introduction">Introduction to
<tt>diag_manager_mod</tt>.</a> <br><a href="#table">Diagnostics Table for
<tt>diag_manager_mod</tt>.</a> <br><a href="#source">Acquiring
<tt>diag_manager_mod</tt> source.</a> <br><a href="#linking">Linking
with <tt>diag_manager_mod</tt>.</a> <br><a
href="#portability">Portability issues.</a> <p>The
<tt>diag_manager_mod</tt> API:<br>
<dl COMPACT>
<dt><a href="#diag_manager_init">diag_manager_init</a>: <dd>Initialize Diagnostics Manager.
<dt><a href="#diag_axis_init">diag_axis_init</a>: <dd>Register Axis
<dt><a href="#register_diag_field">register_diag_field</a>: <dd>Register Diagnostic Field.
<dt><a href="#register_static_field">register_static_field</a>: <dd>Register Static Field.
<dt><a href="#diag_manager_end">diag_manager_end</a>: <dd>Exit Diagnostics Manager.
</dl>
<hr>
</head>
<body>
<ol>

<p><a name="introduction"></a><li><h4>Introduction</h4>

<p><tt>diag_manager_mod</tt> provides a convenient set of interfaces for
writing data to disk.  It is built upon the parallel I/O interface
<a href="../mpp/mpp_io.html"><tt>mpp_io</tt></a>.  A single
group of calls to the <tt>diag_manager_mod</tt> interfaces provides data to disk 
at any number of sampling and/or averaging intervals specified at run-time.     
Run-time specification of diagnostics are input through the 
<a href="#table">Diagnostics Table</a>. 

<p>Features of <tt>diag_manager_mod</tt> include:

<ul>
<li> Simple, minimal API.

<li> Run-time choice of diagnostics

<li> Self-describing files: comprehensive header information
(metadata) in the file itself.

<li> Strong parallel write performance.

<li> Integrated netCDF capability: <a
href="http://www.unidata.ucar.edu/packages/netcdf/">netCDF</a> is a
data format widely used in the climate/weather modeling
community. netCDF is considered the principal medium of data storage
for <tt>diag_manager_mod</tt>. Raw unformatted
fortran I/O capability is also available.

<li> Requires off-line post-processing: a tool for this purpose,
<tt>mppnccombine</tt>, is available. GFDL users may use
<tt>~hnv/pub/mppnccombine</tt>. Outside users may obtain the
source <a
href="ftp://ftp.gfdl.gov/pub/hnv/mpp/mppnccombine-1.0.c">here</a>.  It
can be compiled on any C compiler and linked with the netCDF
library. The program is free and is covered by the <a
href="ftp://ftp.gfdl.gov/pub/hnv/mpp/LICENSE">GPL license</a>.
</ul>

<p><a name="table"></a><li><h4>Diagnostics Table</h4>

<p>The diagnostics table allows users to specify sampling rates and
the choice of fields at run time.  The table consists of
comma-separated ASCII values and may be hand-edited. The preferred
method of building a table is to use the provided GUI interface <tt>diag_table_tk</tt>. 

<p>The table is separated into three sections. 
<ul>
<li>Global section: The first two lines of the table contain the
experiment title and base date.  The base date is the reference time
used for the time units.  The base date must be greater than or equal
to the model start date.  

<li>File section: File lines contain 6
fields - file name, output frequency, output frequency units, file
format (currently only support NetCDF), time units and long name for
time axis.

<li>Field section: Field lines contain 8 fields - module name, field
name, output field name, file name, time sampling (for averaging,
currently only support all timesteps), time average, other operations
(currently not implemented) and pack value (1,2,4 or 8).

</ul>


<p><li><h4>diag_manager_mod call syntax</h4>

<p>The public interfaces to <tt>diag_manager_mod</tt> are described here:

<ol type="a">

<p><a name="diag_manager_init"></a><li><h4>diag_manager_init</h4>

<pre>
subroutine diag_manager_init()
</pre>

<p>Open and read <tt>diag_table</tt>. Select fields and files for diagnostic output.  

<p><a name="diag_manager_end"></a><li><h4>diag_manager_end</h4>

<pre>
subroutine diag_manager_end()
</pre>

<p>Flushes diagnostic buffers where necessary.  Close diagnostics files.

<p><a name="diag_axis_init"></a><li><h4>diag_axis_init</h4>

<p><pre>
function diag_axis_init( name, data, units, cart_name, long_name, &
                          direction, set_name, edges, Domain, Domain2) &
                  result (index) 
! increment axis counter and fill in axes     

!-----------------------------------------------------------------------
!  name                = short name for axis
!  data                = array of coordinate values for this axis
!  units               = units for axis
!  cart_name           = cartesian axis ("x",'y','z','t')
!  direction(optional) = if +1, data are in a up   direction
!                      = if -1, data are in a down direction
!                      = if  0, neither up or down (default)
!  long_name(optional) = long name for axis (default: name)
!  edges    (optional) = axis id for the previously defined "edges axis"
!-----------------------------------------------------------------------

character(len=*), intent(in) :: name
real            , intent(in) :: data(:)
character(len=*), intent(in) :: units
character(len=*), intent(in) :: cart_name

character(len=*), intent(in), optional :: long_name, set_name
integer         , intent(in), optional :: direction, edges
type(domain1d)  , intent(in), optional :: Domain
type(domain2d)  , intent(in), optional :: Domain2
</pre>

<p>Return axis index for subsequent reference in <a
href="#register_diag_field"> register_diag_field </a> or <a
href="#register_static_field"> register_static_field </a>.


<p><a name="register_diag_field"></a><li><h4>register_diag_field</h4>

<p><pre>
function register_diag_field(module_name, field_name, axes, init_time, &
   long_name, units, missing_value, range)

! Indicates the calling modules intent to supply data for this field.

integer ::  register_diag_field
character(len=*), intent(in) :: module_name, field_name
integer, intent(in) :: axes(:)
type(time_type), intent(in) :: init_time
character(len=*), optional, intent(in) :: long_name, units
real, optional, intent(in) :: missing_value, range(2)
</pre>

<p>Return field index for subsequent calls to <a href="#send_data"> send_data </a>.  

<p><a name="register_static_field"></a><li><h4>register_static_field</h4>

<p><pre>
function register_static_field(module_name, field_name, axes, &
   long_name, units, missing_value, range, require)

integer register_static_field
character(len=*), intent(in) :: module_name, field_name
integer, intent(in) :: axes(:)
character(len=*), optional, intent(in) :: long_name, units
real, optional, intent(in) :: missing_value, range(2)
logical, optional, intent(in) :: require  ! require static field 
                                          ! e.g. 2-d axes
</pre>

<p>Return field index for subsequent call to <a href="#send_data"> send_data </a>.  

<p><a name="get_base_time"></a><li><h4>get_base_time</h4>

<p><pre>
 function get_base_time ()
 type(time_type) :: get_base_time
</pre>

<p> Return base time for diagnostics (note: base time must be >= model time).

<p><a name="get_base_data"></a><li><h4>get_base_date</h4>

<pre>
 subroutine get_base_date (year, month, day, hour, minute, second)
   integer, intent(out) :: year, month, day, hour, minute, second
</pre>

<p> Return date information for diagnostic reference time

<P><a name="send_data"></a><li><h4>send_data</h4>

<pre>
function send_data(diag_field_id, field, time, is_in, js_in, ks_in, &
             mask, rmask, weight)

logical :: send_data_3d
integer, intent(in) :: diag_field_id ! id from previous call to <a href=#register_diag_field> register_diag_field </a> 
real, intent(in) :: field(:, :, :)
type (time_type), intent(in) :: time
integer, optional :: is_in, js_in, ks_in ! start indices for array (computational indices)
logical, optional :: mask(:, :, :)
real, optional :: rmask(:, :, :) ! 1 or 0
real, optional :: weight(:, :, :) ! not implemented yet

</pre>

<p><a name="need_data"></a><li><h4>need_data</h4>

<pre>
function need_data(diag_field_id,next_model_time)
!
! next_model_time = current model time + model time_step
!
type (time_type), intent(in) :: next_model_time
integer, intent(in) :: diag_field_id
</pre>

<p> Determine whether data is needed for the current model time step.
Since diagnostic data are buffered, the "next" model time is passed
instead of the current model time.  This call can be used to minimize
overhead for complicated diagnostics.

</ol>

<p><a name="source"></a><li><h4>Acquiring diag_manager_mod source</h4>

<p>GFDL users can checkout diag_manager_mod using the cvs command
<tt>setenv CVSROOT '/home/fms/cvs';cvs co diag_manager</tt>.

<p><a name="linking"></a><li><h4>Compiling and linking to diag_manager_mod</h4>

<p>Any module or program unit using <tt>diag_manager_mod</tt> must
contain the line

<pre>
use diag_manager_mod
</pre>

<p>If netCDF output is desired, the cpp flag <tt>-Duse_netCDF</tt>
must be turned on. The loader step requires an explicit link to the
netCDF library (typically something like <tt>-L/usr/local/lib
-lnetcdf</tt>, depending on the path to the netCDF library).
<a href="http://www.unidata.ucar.edu/packages/netcdf/guidef">netCDF
release 3 for fortran</a> is required.


<p><a name="portability"></a><li><h4>Portability</h4>

<tt>diag_manager_mod</tt> uses standard f90. 



<p><a name="Changes"></a><li><h4>Changes</h4>

The <a href="changes_diag_manager.html">RCS log</a> for
<tt>diag_manager.F90</tt> contains a comprehensive list of changes. In the
unlikely event that you should wish to check out a retro version,
please get in touch with me, <a href="myaddr.html">Matt Harrison</a>.

</ol>

<!-- footer using address stylespec -->
<br><hr>
<address>
Author: <a href="myaddr.html">Matt Harrison</a>
<br>Document last modified <!--#exec cmd="echo $LAST_MODIFIED" --></small>
</address>
</body>

<!-- store access stats -->
<!--#exec cmd="touch stats; chmod 666 stats" -->
<!--#exec cmd="echo $DOCUMENT_NAME $REMOTE_HOST $DATE_LOCAL >> stats" -->
</html>
