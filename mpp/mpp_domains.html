<!doctype html public "-//ietf//dtd html//en">
<html>

<head>
<meta name="description" content="">
<meta name="keywords" content="">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" href="http://www.gfdl.noaa.gov/~fms/style/balaji.css">

<title>mpp_domains: a domain decomposition programming interface
for f90</title>
</head>

<body>

<!-- title using title stylespec -->
<div class="title">
<h1>mpp_domains_mod</h1>
<h2> a domain decomposition programming interface for f90</h2>
<hr>
<tt>mpp_domains_mod</tt> is a set of simple calls for domain
decomposition and domain updates on rectilinear grids. It requires the
module <a href="mpp.html"><tt>mpp_mod</tt></a>, upon which it is built.
<hr>
</div>

<p>
<br><a href="#introduction">Introduction to <tt>mpp_domains_mod</tt>.</a>
<br><a href="#domains">Domain specification in <tt>mpp_domains_mod</tt>.</a>
<br><a href="#source">Acquiring <tt>mpp_domains_mod</tt> source.</a>
<br><a href="#linking">Linking with <tt>mpp_domains_mod</tt>.</a>
<br><a href="#portability">Portability issues.</a>

<p>The <tt>mpp_domains_mod</tt> API:<br>

<p><dl>

<dt><a href="#mpp_define_domains"><tt>mpp_define_domains</tt></a>:
<dd>Set up a domain decomposition.

<dt><a href="#mpp_define_layout"><tt>mpp_define_layout</tt></a>:
<dd>Set up a 2D domain layout for the decomposition.

<dt><a href="#mpp_domains_exit"><tt>mpp_domains_exit</tt></a>:
<dd>Exit <tt>mpp_domains_mod</tt>.

<dt><a href="#mpp_domains_init"><tt>mpp_domains_init</tt></a>:
<dd>Initialize <tt>mpp_domains_mod</tt>.

<dt><a
href="#mpp_domains_set_stack_size"><tt>mpp_domains_set_stack_size</tt></a>:
<dd>Set user stack size.

<dt><a href="#mpp_get_active_domain"><tt>mpp_get_active_domain</tt>,
etc.</a>: <dd>Domain retrieval routines.

<dt><a
href="#mpp_get_domain_components"><tt>mpp_get_domain_components</tt></a>:
<dd>Retrieve 1D components of 2D decomposition.

<dt><a href="#mpp_get_layout"><tt>mpp_get_layout</tt></a>:
<dd>Retrieve layout associated with a domain decomposition.

<dt><a href="#mpp_get_pelist"><tt>mpp_get_pelist</tt></a>:
<dd>Retrieve list of PEs associated with a domain decomposition.

<dt><a href="#mpp_global_field"><tt>mpp_global_field</tt></a>:
<dd>Fill in a global array from domain-decomposed arrays.

<dt><a href="#mpp_global_sum"><tt>mpp_global_sum</tt></a>:
<dd>Global sum of domain-decomposed arrays.

<dt><a href="#mpp_global_max"><tt>mpp_global_max, mpp_global_min</tt></a>:
<dd>Global max/min of domain-decomposed arrays.

<dt><a href="#mpp_update_domains"><tt>mpp_update_domains</tt></a>:
<dd>Halo updates, data transposes.

<dt><a href="#operators">Operators on domaintypes</a>:
<dd>Equality/inequality operators for domaintypes.

</dl>
<hr>
<ol>

<p><a name="introduction"><li><h4>Introduction</h4>

<p>Scalable implementations of finite-difference codes are generally
based on decomposing the model domain into subdomains that are
distributed among processors. These domains will then be obliged to
exchange data at their boundaries if data dependencies are merely
nearest-neighbour, or may need to acquire information from the global
domain if there are extended data dependencies, as in the spectral
transform. The domain decomposition is a key operation in the
development of parallel codes.

<p><tt>mpp_domains_mod</tt> provides a domain decomposition and domain
update API for <i>rectilinear</i> grids, built on top of the <a
href="./mpp.html"><tt>mpp_mod</tt></a> API for message passing. Features
of <tt>mpp_domains_mod</tt> include:

<ul>
<li> Simple, minimal API, with free access to underlying API for
  more complicated stuff.
<li> Design toward typical use in climate/weather CFD codes.
</ul>

<p><a name="domains"><li><h4>Domains</h4>

I have assumed that domain decomposition will mainly be in 2
horizontal dimensions, which will in general be the two
fastest-varying indices. There is a separate implementation of 1D
decomposition on the fastest-varying index, and 1D decomposition on
the second index, treated as a special case of 2D decomposition, is
also possible.

We define <i>domain</i> as the grid associated with a <i>task</i>.
We define the <i>compute domain</i> as the set of gridpoints that are
computed by a task, and the <i>data domain</i> as the set of points
that are required by the task for the calculation. There can in
general be more than 1 task per PE, though often
the number of domains is the same as the processor count. We define
the <i>global domain</i> as the global computational domain of the
entire model (i.e, the same as the computational domain if run on a
single processor).

2D domains are defined using a derived type <tt>domain2D</tt>,
constructed as follows (see comments in code for more details):

<pre>
  type, public :: domain_axis_spec
     private
     integer :: begin, end, size, max_size
     logical :: is_global
  end type domain_axis_spec
  type, public :: domain1D
     private
     type(domain_axis_spec) :: compute, data, global, active
     logical :: mustputb, mustgetb, mustputf, mustgetf, folded
     type(domain1D), pointer, dimension(:) :: list
     integer :: pe              !PE to which this domain is assigned
     integer :: pos
  end type domain1D
!domaintypes of higher rank can be constructed from type domain1D
!typically we only need 1 and 2D, but could need higher (e.g 3D LES)
!some elements are repeated below if they are needed once per domain
  type, public :: domain2D
     private
     type(domain1D) :: x
     type(domain1D) :: y
     type(domain2D), pointer, dimension(:) :: list
     integer :: pe              !PE to which this domain is assigned
     integer :: pos
  end type domain2D
  type(domain1D), public :: NULL_DOMAIN1D
  type(domain2D), public :: NULL_DOMAIN2D
</pre>

The <tt>domain2D</tt> type contains all the necessary information to
define the global, compute and data domains of each task, as well as the PE
associated with the task. The PEs from which remote data may be
acquired to update the data domain are also contained in a linked list
of neighbours.

<p><li><h4>mpp_domains_mod call syntax</h4>

<p>The public interfaces to <tt>mpp_domains_mod</tt> are
described here in alphabetical order:

<ol type="a">

<p><a name="mpp_define_domains"><li><h4><tt>mpp_define_domains</tt></h4>

<p>There are two forms for the <tt>mpp_define_domains</tt> call. The 2D
version is generally to be used but is built by repeated calls to the
1D version, also provided.

<p>The 1D version is as follows:

<p><pre>
subroutine mpp_define_domains( global_indices, ndivs, domain, &
                               pelist, flags, halo, extent, maskmap )
  integer, intent(in) :: global_indices(2)
  integer, intent(in) :: ndivs
  type(domain1D), intent(inout) :: domain
  integer, intent(in), optional :: pelist(:)
  integer, intent(in), optional :: flags, halo
  integer, intent(in), optional :: extent(:)
  logical, intent(in), optional :: maskmap(:)
</pre>

<p><dl>

<dt><tt>global_indices</tt><dd> defines the global domain

<dt><tt>ndivs</tt><dd> is the number of domain divisions required.

<dt><tt>domain</tt><dd>holds the resulting domain decomposition.

<dt><tt>pelist</tt><dd>list of PEs to which the domains are to be assigned.

<dt><tt>flags</tt><dd>an optional flag to pass additional information
about the desired domain topology. Useful flags in a 1D decomposition
include <tt>GLOBAL_DATA_DOMAIN</tt> and
<tt>CYCLIC_GLOBAL_DOMAIN</tt>. Flags are integers: multiple flags may
be added together. The flag values are public parameters available by
use association.

<dt><tt>halo</tt><dd>width of the halo.

<dt><tt>extent</tt><dd>Normally <tt>mpp_define_domains</tt> attempts
an even division of the global domain across <tt>ndivs</tt>
domains. The <tt>extent</tt> array can be used by the user to pass a
custom domain division. The <tt>extent</tt> array has <tt>ndivs</tt>
elements and holds the compute domain widths, which should add up to
cover the global domain exactly.

<dt><tt>maskmap</tt><dd>Some divisions may be masked
(<tt>maskmap=.FALSE.</tt>) to exclude them from the computation (e.g
for ocean model domains that are all land). The <tt>maskmap</tt> array
is dimensioned <tt>ndivs</tt> and contains <tt>.TRUE.</tt> values for
any domain that must be <i>included</i> in the computation (default
all). The <tt>pelist</tt> array length should match the number of
domains included in the computation.

</dl>

<p>For example:

<pre>
call mpp_define_domains( (/1,100/), 10, domain, &
     flags=GLOBAL_DATA_DOMAIN+CYCLIC_GLOBAL_DOMAIN, halo=2 )
</pre>

<p>defines 10 compute domains spanning the range [1,100] of the global
domain. The compute domains
are non-overlapping blocks of 10. All the data domains are global, and
with a halo of 2 span the range [-1:102]. And
since the global domain has been declared to be cyclic,
<tt>domain(9)%next => domain(0)</tt> and <tt>domain(0)%prev =>
domain(9)</tt>.

A field is allocated on the data domain, and computations proceed on
the compute domain. A call to <a
href="#mpp_update_domains"><tt>mpp_update_domains</tt></a> would fill in
the values in the halo region:

<pre>
call mpp_get_data_domain( domain, isd, ied ) !returns -1 and 102
call mpp_get_compute_domain( domain, is, ie ) !returns (1,10) on PE 0 ...
allocate( a(isd:ied) )
do i = is,ie
   a(i) = &lt;perform computations&gt;
end do
call mpp_update_domains( a, domain )
</pre>

<p>The call to <tt>mpp_update_domains</tt> fills in the regions outside
the compute domain. Since the global domain is cyclic, the values at
<tt>i=(-1,0)</tt> are the same as at <tt>i=(99,100)</tt>; and
<tt>i=(101,102)</tt> are the same as <tt>i=(1,2)</tt>.

<p>The 2D version is just an extension of this syntax to two
dimensions:

<pre>
subroutine mpp_define_domains( global_indices, layout, domain, pelist, &
                               xflags, yflags, xhalo, yhalo, xextent, yextent, &
			       maskmap, name )
  integer, intent(in) :: global_indices(4) !(/ isg, ieg, jsg, jeg /)
  integer, intent(in) :: layout(2)
  type(domain2D), intent(inout) :: domain
  integer, intent(in), optional :: pelist(:)
  integer, intent(in), optional :: xflags, yflags, xhalo, yhalo
  integer, intent(in), optional :: xextent(:), yextent(:)
  logical, intent(in), optional :: maskmap(:,:)
  character(len=*), optional :: name
</pre>

<p>This is a 2D version of the above, and should generally be used in
codes, including 1D-decomposed ones, if there is a possibility of
future evolution toward 2D decomposition. The arguments are similar to
the 1D case, except that now we have optional arguments
<tt>flags</tt>, <tt>halo</tt>, <tt>extent</tt> and <tt>maskmap</tt>
along two axes.

<p><tt>flags</tt> can now take an additional possible value to fold
one or more edges. This is done by using flags
<tt>FOLD_WEST_EDGE</tt>, <tt>FOLD_EAST_EDGE</tt>,
<tt>FOLD_SOUTH_EDGE</tt> or <tt>FOLD_NORTH_EDGE</tt>. When a fold
exists (e.g cylindrical domain), vector fields reverse parity upon
crossing the fold. This parity reversal is performed by specifying the
optional flag <tt>type=VECTOR_COMPONENT</tt> on the call to <a
href="#mpp_update_domains"><tt>mpp_update_domains</tt></a>.

<p><tt>name</tt> is the name associated with the decomposition,
e.g <tt>'Ocean model'</tt>. If this argument is present,
<tt>mpp_define_domains</tt> will print the domain decomposition
generated.

<p>Examples:

<pre>
call mpp_define_domains( (/1,100,1,100/), (/2,2/), domain, xhalo=1 )
</pre>

<p>will create the following domain layout:
<p><table border>
<tr> <td></td> <th>domain(1)</th> <th>domain(2)</th>
<th>domain(3)</th>  <th>domain(4)</th> </tr>
<tr> <th>Compute domain</th> <td>1,50,1,50</td> <td>51,100,1,50</td>
<td>1,50,51,100</td>  <td>51,100,51,100</td> </tr>
<tr> <th>Data domain</th> <td>0,51,1,50</td> <td>50,101,1,50</td>
<td>0,51,51,100</td>  <td>50,101,51,100</td> </tr>
</table>

<p>Again, we allocate arrays on the data domain, perform computations
on the compute domain, and call <tt>mpp_update_domains</tt> to update
the halo region.

<p>If we wished to perfom a 1D decomposition along <tt>Y</tt>
on the same global domain, we could use:

<p><pre>
call mpp_define_domains( (/1,100,1,100/), layout=(/4,1/), domain, xhalo=1 )
</pre>

<p>This will create the following domain layout:
<p><table border>
<tr> <td></td> <th>domain(1)</th> <th>domain(2)</th>
<th>domain(3)</th>  <th>domain(4)</th> </tr>
<tr> <th>Compute domain</th> <td>1,100,1,25</td> <td>1,100,26,50</td>
<td>1,100,51,75</td>  <td>1,100,76,100</td> </tr>
<tr> <th>Data domain</th> <td>0,101,1,25</td> <td>0,101,26,50</td>
<td>0,101,51,75</td>  <td>0,101,76,100</td> </tr>
</table>

<p><a name="mpp_define_layout"><li><h4><tt>mpp_define_layout</tt></h4>

<pre>
subroutine mpp_define_layout( global_indices, ndivs, layout )
  integer, intent(in) :: global_indices(4) !(/ isg, ieg, jsg, jeg /)
  integer, intent(in) :: ndivs !number of divisions to divide global domain
  integer, intent(out) :: layout(2)
</pre>

<p>Given a global 2D domain and the number of divisions in the
decomposition (<tt>ndivs</tt>: usually the PE count unless some
domains are masked) this calls returns a 2D domain layout.

<p>By default, <tt>mpp_define_layout</tt> will attempt to divide the
2D index space into domains that maintain the aspect ratio of the
global domain. If this cannot be done, the algorithm favours domains
that are longer in <tt>x</tt> than <tt>y</tt>, a preference that could
improve vector performance.

<p><a name="mpp_domains_exit"><li><h4><tt>mpp_domains_exit</tt></h4>

<pre>
subroutine mpp_domains_exit
</pre>

<p>Serves no particular purpose, but is provided should you require to
re-initialize <tt>mpp_domains_mod</tt>, for some odd reason.

<p><a name="mpp_domains_init"><li><h4><tt>mpp_domains_init</tt></h4>

<pre>
subroutine mpp_domains_init(flags)
  integer, optional, intent(in) :: flags
</pre>

<p>Called to initialize the <tt>mpp_domains_mod</tt> package.

<p><tt>flags</tt> can be set to <tt>MPP_VERBOSE</tt> to have
<tt>mpp_domains_mod</tt> keep you informed of what it's up
to. <tt>MPP_DEBUG</tt> returns even more information for debugging.

<p><tt>mpp_domains_init</tt> will call <tt>mpp_init</tt>, to make sure
<a href="mpp.html"><tt>mpp_mod</tt></a> is initialized. (Repeated
calls to <tt>mpp_init</tt> do no harm, so don't worry if you already
called it).

<p><a name="mpp_domains_set_stack_size"><li><h4><tt>mpp_domains_set_stack_size</tt></h4>

<pre>
subroutine mpp_domains_set_stack_size(n)
  integer, intent(in) :: n
</pre>

<p>This sets the size of an array that is used for internal storage by
<tt>mpp_domains</tt>. This array is used, for instance, to buffer the
data sent and received in halo updates.

<p>This call has implied global synchronization. It should be
placed somewhere where all PEs can call it.

<p><a name="mpp_get_active_domain"><li><h4>Domain retrieval routines</h4>

<p>The domain is a derived type with private elements. The retrieval
routines retrieve various elements of the type. To retrieve axis
specifications associated with a <tt>domain1D</tt> type:

<p><pre>
subroutine mpp_get_active_domain ( domain, begin, end, size, max_size )
subroutine mpp_get_compute_domain( domain, begin, end, size, max_size )
subroutine mpp_get_data_domain   ( domain, begin, end, size, max_size )
subroutine mpp_get_global_domain ( domain, begin, end, size, max_size )
  type(domain1D), intent(in) :: domain
  integer, intent(out), optional :: begin, end, size, max_size
</pre>

<p>These routines retrieve the axis specifications associated with the
active, compute, data or global domains. The 2D version of these is a
simple extension:

<p><pre>
subroutine mpp_get_active_domain ( domain, xbegin, xend, ybegin, yend, &
                                           xsize, xmax_size, ysize, ymax_size )
subroutine mpp_get_compute_domain( domain, xbegin, xend, ybegin, yend, &
                                           xsize, xmax_size, ysize, ymax_size )
subroutine mpp_get_data_domain   ( domain, xbegin, xend, ybegin, yend, &
                                           xsize, xmax_size, ysize, ymax_size )
subroutine mpp_get_global_domain ( domain, xbegin, xend, ybegin, yend, &
                                           xsize, xmax_size, ysize, ymax_size )
  type(domain2D), intent(in) :: domain
  integer, intent(out), optional :: xbegin, xend, ybegin, yend, &
                                    xsize, xmax_size, ysize, ymax_size
</pre>

<p>In addition, it is often useful to retrieve the entire array of
compute domain extents associated with a decomposition. This is done
as follows:

<p><pre>
subroutine mpp_get_compute_domains( domain, xbegin, xend, xsize, &
                                            ybegin, yend, ysize )
  type(domain2D), intent(in) :: domain
  integer, intent(out), optional, dimension(:) :: xbegin, xend, xsize, &
                                                  ybegin, yend, ysize )
</pre>

<p><a name="mpp_get_domain_components"><li><h4><tt>mpp_get_domain_components</tt></h4>

<p><pre>
subroutine mpp_get_domain_components( domain, x, y )
  type(domain2D), intent(in) :: domain
  type(domain1D), intent(out), optional :: x, y
</pre>

<p>It is sometime necessary to have direct recourse to the
<tt>domain1D</tt> types that compose a <tt>domain2D</tt> object. This
call retrieves them.

<p><a name="mpp_get_layout"><li><h4><tt>mpp_get_layout</tt></h4>

<p>The 1D version of this call is:

<p><pre>
subroutine mpp_get_layout( domain, layout )
  type(domain1D), intent(in) :: domain
  integer, intent(out) :: layout
</pre>

<p>This returns the number of divisions that was assigned to this
decomposition axis. The 2D version of this call returns an array of
dimension 2 holding the results on two axes:

<p><pre>
subroutine mpp_get_layout( domain, layout )
  type(domain2D), intent(in) :: domain
  integer, intent(out) :: layout(2)
</pre>

<p><a name="mpp_get_pelist"><li><h4><tt>mpp_get_pelist</tt></h4>

<p>The 1D version of this call is:

<p><pre>
subroutine mpp_get_pelist( domain, pelist, pos )
  type(domain1D), intent(in) :: domain
  integer, intent(out) :: pelist(0:)
  integer, intent(out), optional :: pos
</pre>

<p>This returns an array of the PEs assigned to this 1D domain
decomposition. In addition the optional argument <tt>pos</tt> may be
used to retrieve the 0-based position of the domain local to the
calling PE, i.e <tt>domain%list(pos)%pe</tt> is the local PE,
as returned by <a href="mpp.html#mpp_pe"><tt>mpp_pe()</tt></a>.

The 2D version of this call is identical:

<p><pre>
subroutine mpp_get_pelist( domain, pelist, pos )
  type(domain2D), intent(in) :: domain
  integer, intent(out) :: pelist(:)
  integer, intent(out), optional :: pos
</pre>

<p><a name="mpp_global_field"><li><h4><tt>mpp_global_field</tt></h4>

<p><pre>
subroutine mpp_global_field( domain, local, global, flags )
  type(domain2D), intent(in) :: domain
  MPP_TYPE_, intent(in)  ::  local
  MPP_TYPE_, intent(out) :: global
  integer, intent(in), optional :: flags
</pre>

<p><tt>mpp_global_field</tt> is used to get an entire
domain-decomposed array on each PE. <tt>MPP_TYPE_</tt> can be of type
<tt>complex</tt>, <tt>integer</tt>, <tt>logical</tt> or <tt>real</tt>;
of 4-byte or 8-byte kind; of rank up to 5.

<p><tt>local</tt> is dimensioned on either the compute domain or the
data domain of <tt>domain</tt>, <tt>global</tt> is dimensioned on the
corresponding global domain.

<p><tt>flags</tt> can be given the value <tt>XONLY</tt> or
<tt>YONLY</tt>, to specify a globalization on one axis only.

<p>All PEs in a domain decomposition must call
<tt>mpp_global_field</tt>, and each will have a complete global field
at the end. Please note that a global array of rank 3 or higher could
occupy a lot of memory.

<p><a name="mpp_global_max"><li><h4><tt>mpp_global_max</tt></h4>

<p><pre>
function mpp_global_max( domain, field, locus )
  MPP_TYPE_ :: mpp_global_max
  type(domain2D), intent(in) :: domain
  MPP_TYPE_, intent(in) :: field
  integer, intent(out), optional :: locus(:)
</pre>

<p><tt>mpp_global_max</tt> is used to get the maximum value of a
domain-decomposed array on each PE. <tt>MPP_TYPE_</tt> can be of type
<tt>integer</tt> or <tt>real</tt>; of 4-byte or 8-byte kind; of rank
up to 5. The dimension of <tt>locus</tt> must equal the rank of
<tt>field</tt>.

<p><tt>field</tt> is dimensioned on either the compute domain or the
data domain of <tt>domain</tt>.

<p><tt>locus</tt>, if present, can be used to retrieve the location of
the maximum (as in the <tt>MAXLOC</tt> intrinsic of f90).

<p>All PEs in a domain decomposition must call
<tt>mpp_global_max</tt>, and each will have the result upon exit.

<p>The function <tt>mpp_global_min</tt>, with an identical syntax. is
also available.

<p><a name="mpp_global_sum"><li><h4><tt>mpp_global_sum</tt></h4>

<p><pre>
function mpp_global_sum( domain, field, flags )
  MPP_TYPE_ :: mpp_global_sum
  type(domain2D), intent(in) :: domain
  MPP_TYPE_, intent(in) :: field
  integer, intent(in), optional :: flags
</pre>

<p><tt>mpp_global_sum</tt> is used to get the sum of a
domain-decomposed array on each PE. <tt>MPP_TYPE_</tt> can be of type
<tt>integer</tt>, <tt>complex</tt>, or <tt>real</tt>; of 4-byte or
8-byte kind; of rank up to 5.

<p><tt>field</tt> is dimensioned on either the compute domain or the
data domain of <tt>domain</tt>.

<p><tt>flags</tt>, if present, must have the value
<tt>BITWISE_EXACT_SUM</tt>. This produces a sum that is guaranteed to
produce the identical result irrespective of how the domain is
decomposed. This method does the sum first along the ranks beyond 2,
and then calls <a
href="#mpp_global_field"><tt>mpp_global_field</tt></a> to produce a
global 2D array which is then summed. The default method, which is
considerably faster, does a local sum followed by <a
href="mpp.html#mpp_sum"><tt>mpp_sum</tt></a> across the domain
decomposition.

<p>All PEs in a domain decomposition must call
<tt>mpp_global_sum</tt>, and each will have the result upon exit.

<p><a name="mpp_update_domains"><li><h4>mpp_update_domains</h4>

<p><pre>
subroutine mpp_update_domains( field, domain, flags, type )
  MPP_TYPE_, intent(inout) :: field
  type(domain2D), intent(inout), target :: domain
  integer, intent(in), optional :: flags, type
</pre>

<p><tt>mpp_update_domains</tt> is used to perform a halo update of a
domain-decomposed array on each PE. <tt>MPP_TYPE_</tt> can be of type
<tt>complex</tt>, <tt>integer</tt>, <tt>logical</tt> or <tt>real</tt>;
of 4-byte or 8-byte kind; of rank up to 5.

<p><tt>flags</tt> is used when <tt>domain</tt> is
<tt>type(domain2D)</tt>. For 2D domain updates, if there are halos
present along both <tt>x</tt> and <tt>y</tt>, we can choose to update
one only, by specifying <tt>flags=XUPDATE </tt>or
<tt>flags=YUPDATE</tt>. In addition, one-sided updates can be
performed by setting <tt>flags</tt> to any combination of
<tt>WUPDATE</tt>, <tt>EUPDATE</tt>, <tt>SUPDATE</tt> and
<tt>NUPDATE</tt>, to update the west, east, north and south halos
respectively. Any combination of halos may be used by adding the
requisite flags, e.g: <tt>flags=XUPDATE+SUPDATE</tt> or
<tt>flags=EUPDATE+WUPDATE+SUPDATE</tt> will update the east, west and
south halos.

<p>If a call to <tt>mpp_update_domains</tt> involves at least one E-W
halo and one N-S halo, the corners involved will also be updated, i.e,
in the example above, the SE and SW corners will be updated.

<p>If <tt>flags</tt> is not supplied, that is
equivalent to <tt>flags=XUPDATE+YUPDATE</tt>.

<p>The optional argument <tt>type</tt> may be set to
<tt>VECTOR_COMPONENT</tt> to specify to <tt>mpp_domains</tt> that the
array being updated is a vector field. Vector fields require special
treatment on certain topologies, where they may change sign when
crossing a boundary. (As an example, consider a cylindrical projection
using the flags <tt>FOLD_SOUTH_EDGE</tt> and <tt>FOLD_NORTH_EDGE</tt>
in the call to <tt>mpp_define_domains</tt>: vectors change sign when
crossing that boundary). This argument may be extended to other uses
in the future: currently <tt>VECTOR_COMPONENT</tt> is the only
meaningful value.

<p>It is safe to specify <tt>type=VECTOR_COMPONENT</tt> for the
appropriate arrays irrespective of the domain topology: if the
topology requires no special treatment of vector fields, specifying
this will do no harm.

<p><tt>mpp_update_domains</tt> internally buffers the date being sent
and received into single messages for efficiency. A tunable internal
buffer area in memory is provided for this purpose by
<tt>mpp_domains_mod</tt>. The size of this buffer area can be set by
the user by calling <a
href="mpp_domains.html#mpp_domains_set_stack_size">
<tt>mpp_domains_set_stack_size</tt></a>.

<p><a name="operators"><li><h4>Operators on domaintypes</h4>

<p>The module provides public operators to check for
equality/inequality of domaintypes, e.g:

<p><pre>
type(domain1D) :: a, b
type(domain2D) :: c, d
...
if( a.NE.b )then
    ...
end if
if( c==d )then
    ...
end if
</pre>

<p>Domains are considered equal if and only if the start and end
indices of each of their component global, data and compute domains
are equal.

</ol>

<p><a name="source"><li><h4>Acquiring mpp_domains_mod source</h4>

<p>GFDL users can copy the file
<tt>/net/vb/public/mpp/mpp_domains.F90</tt>. External users can
download the source <a
href="ftp://ftp.gfdl.gov/pub/vb/mpp/mpp_domains.F90">here</a>. The
current public version number is 5.1.

<p><a name="linking"><li><h4>Compiling and linking to mpp_domains_mod</h4>

<p>Any module or program unit using <tt>mpp_domains_mod</tt>
must contain the line

<pre>
use mpp_domains_mod
</pre>

<p><tt>mpp_domains_mod</tt> <tt>use</tt>s <a
href="mpp.html"><tt>mpp_mod</tt></a>, and therefore is subject to the <a
href="mpp.html#linking">compiling and linking requirements of that module.</a>

<p><a name="portability"><li><h4>Portability issues</h4>

<tt>mpp_domains_mod</tt> uses standard f90, and has no special
requirements. There are some <a href="os.html">OS-dependent
pre-processor directives</a> that you might need to modify on
non-SGI/Cray systems and compilers. The <a
href="mpp.html#portability">portability of <tt>mpp_mod</tt></a>
obviously is a constraint, since this module is built on top of
it. Contact me, <a href="myaddr.html">Balaji</a>, SGI/GFDL, with
questions.

<p><a name="Changes"></a><li><h4>Changes</h4>

The <a href="changes_mpp_domains.html">RCS log</a> for
<tt>mpp_domains.F90</tt> contains a comprehensive list of
changes. In the unlikely event that you should wish to check out a
retro version, please get in touch with me, <a
href="myaddr.html">Balaji</a>.
</ol>

<!-- footer using address stylespec -->
<br><hr>
<address>
Author: <a href="myaddr.html">V. Balaji</a><br>
Document last modified <!--#exec cmd="echo $LAST_MODIFIED" -->
</address>
</body>

<!-- store access stats -->
<!--#exec cmd="touch stats; chmod 666 stats" -->
<!--#exec cmd="echo $DOCUMENT_NAME $REMOTE_HOST $HTTP_REFERER $DATE_LOCAL >> stats" -->
</html>
